import sys
import os
from krita import *

# API Listing: https://github.com/scottpetrovic/krita-python-auto-complete/blob/master/output/PyKrita.py
def link_external_packages():
    # get the path to the pykrita directory located in the Resource Directory
    resource_dir = str(Krita.instance().readSetting("", "ResourceDirectory", ""))
    pykrita_resource_dir =  os.path.join(resource_dir, "pykrita")
    lib_file_path = os.path.join(pykrita_resource_dir, "my_extension/lib")

    # fetch the dependecy path that was generated in the .lib file generated by our build script
    with open(lib_file_path, "r") as f:
        dep_path = os.path.join(pykrita_resource_dir, f.readline()[:-1])

    # set the path if not already set
    if dep_path not in sys.path:
        sys.path.append(dep_path)
        sys.path.append(os.path.join(pykrita_resource_dir, "my_extension"))

# THIS NEEDS TO BE CALLED BEFORE WE CAN PERFORM ANY OPERATIONS WITH EXTERNAL LIBRARIES 
link_external_packages()

from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
import numpy as np
import cv2
from PIL import Image
import subprocess
import json
from palette import PaletteGrid

from engine import Engine

WORKING_DIR = os.path.join(str(Krita.instance().readSetting("", "ResourceDirectory", "")), "pykrita")
XTC_PATH = os.path.join(WORKING_DIR, "my_extension/core/xt_consistency/")
# images
INPUT_IMAGE_PATH   = os.path.join(WORKING_DIR, "my_extension/INPUT_IMAGE.png")
INPUT_MASK_PATH   = os.path.join(WORKING_DIR, "my_extension/INPUT_MASK.png")
OUTPUT_IMAGE_PATH  = os.path.join(WORKING_DIR, "my_extension/OUTPUT_IMAGE.png")
OUTPUT_NORMAL_PATH  = os.path.join(WORKING_DIR, "my_extension/OUTPUT_NORMAL.png")
# engine runner files
ENGINE_PYTHON_PATH = os.path.join(WORKING_DIR, "deps/bin/python3.9")
PIXELIZER_ENTRY_POINT = os.path.join(WORKING_DIR, "my_extension/core/pixelizer.py")
NORMALGEN_ENTRY_POINT = os.path.join(WORKING_DIR, "my_extension/core/normal_gen.py")
CONFIG_PATH = os.path.join(WORKING_DIR, "my_extension/engine.cfg")

IM_MODE = "RGBA"
# =================================== Extension ==================================

class MyExtension(DockWidget):
    def __init__(self):
        super().__init__()
        self.setup_gui()

    def canvasChanged(self, canvas):
        pass

    def popup(self, message):
        QMessageBox.information(QWidget(), "something", message)

    def setup_gui(self):
        self.setWindowTitle("Pixelizer and Normal Map Generator")
        # main view
        main_widget = QWidget(self)
        self.setWidget(main_widget)
        # form layout
        self.pix_form_layout = QFormLayout()
        main_widget.setLayout(self.pix_form_layout)

        # run engine button
        self.btn_run_engine = QPushButton("Generate!", main_widget)
        self.btn_run_engine.setToolTip("Generate the pixel image and normal map!")
        self.btn_run_engine.clicked.connect(self.run_engine)
        # btn_run_engine.clicked.connect(self.test_func)

        # ================ Pixelate Inputs ================ #
        # Scale factor
        self.input_scale = QLineEdit()
        self.input_scale.setValidator(QIntValidator(bottom=1, top=20))
        self.input_scale.setMaxLength(2)
        self.input_scale.setText("4")
        # Number of colors
        self.input_palette_size = QLineEdit()
        self.input_palette_size.setValidator(QIntValidator(bottom=1))
        self.input_palette_size.setMaxLength(3)
        self.input_palette_size.setText("12")
        # Dither
        self.input_dither = QComboBox()
        self.input_dither.addItems([
            "none",
            "naive",
            "bayer",
            "floyd",
            "atkinson"
        ])
        self.input_dither.setInsertPolicy(QComboBox.NoInsert)
        # scale output checkbox
        self.scale_checkbox = QCheckBox("")
        self.scale_checkbox.setChecked(False)

        # normal generator params
        # Number of colors in normal map
        self.input_norm_palette_size = QLineEdit()
        self.input_norm_palette_size.setValidator(QIntValidator(bottom=1))
        self.input_norm_palette_size.setMaxLength(3)
        self.input_norm_palette_size.setText("16")

        # progress bart
        self.loading_bar = QProgressBar()
        self.loading_bar.setFixedHeight(12)
        self.loading_bar.setTextVisible(False)
        self.loading_bar.setVisible(False)
        self.loading_bar.setRange(0,0)

        # add the widgets to the form
        self.pix_form_layout.addRow("Scale factor", self.input_scale)
        self.pix_form_layout.addRow("Palette size", self.input_palette_size)
        self.pix_form_layout.addRow("Dither mode", self.input_dither)
        self.pix_form_layout.addRow("Rescale output?", self.scale_checkbox)
        self.pix_form_layout.addRow("# of colours in normal map", self.input_norm_palette_size)
        self.pix_form_layout.addRow(self.loading_bar)
        self.pix_form_layout.addRow(self.btn_run_engine)

    def test_func(self):
        active_doc = Krita.instance().activeDocument()
        # get the active layer with its dimensions
        layer = active_doc.activeNode()
        doc_width = active_doc.width()
        doc_height = active_doc.height()

        # save the selection mask
        selection = Krita.instance().activeDocument().selection()
        mask = np.zeros((doc_height, doc_width), dtype=np.uint8)
        if selection == None:
            # no selection!
            # self.popup("{} {} {} {} {}".format(selection.x(), selection.y(), doc_width, doc_height, len(pixels)))
            # take the full image
            mask = mask + 255
        else:
            # get the pixel data from the selection
            mask_x, mask_y = selection.x(), selection.y()
            mask_width, mask_height = selection.width(), selection.height()
            pixels = selection.pixelData(mask_x, mask_y, mask_width, mask_height)
            # create and save the binary mask
            obj_mask = Engine.selection2mask(pixels, mask_width, mask_height)
            mask[mask_y:mask_y+mask_height, mask_x:mask_x+mask_width] = obj_mask
        cv2.imwrite(INPUT_IMAGE_PATH, mask)

    def get_input_values(self):
        return {
            "factor": int(self.input_scale.text()),
            "palette": int(self.input_palette_size.text()),
            "dither": self.input_dither.currentText(),
            "norm_palette": int(self.input_palette_size.text()),
        }

    def error_popup(self, message: str):
        msg_popup = QMessageBox()
        msg_popup.setIcon(QMessageBox.Critical)
        msg_popup.setText("There was an issue...")
        msg_popup.setInformativeText(message)
        msg_popup.setStandardButtons(QMessageBox.Ok)
        msg_popup.exec()
    
    def show_colour_palette(self, img):
        # rgb image to hex
        img_hex = np.asarray(img, dtype=np.uint32)
        img_hex = ((img_hex[:,:,0]<<16) + (img_hex[:,:,1]<<8) + img_hex[:,:,2])

        # find unique colours and assign the hex string
        palette = np.unique(img_hex.reshape(-1, img_hex.shape[-1]))
        palette = palette.tolist()
        for i in range(len(palette)):
            c_str = str(hex(palette[i]))
            c_str = "#" + c_str[2:]
            if len(c_str) < 8:
                c_str += "000000"[:8-len(c_str)-1]
            palette[i] = c_str

        palette_grid = PaletteGrid(palette)
        self.pix_form_layout.addRow(palette_grid)

    def run_engine(self):
        rescale_output = self.scale_checkbox.isChecked()

        input_values = self.get_input_values()

        # get the current active document opened on krita
        active_doc = Krita.instance().activeDocument()

        if active_doc == None:
            self.error_popup("An image has not been loaded yet!")
            return

        # get the active layer with its dimensions
        layer = active_doc.activeNode()
        doc_width = active_doc.width()
        doc_height = active_doc.height()

        # get pixel data from the image
        pixel_data = layer.pixelData(0, 0, doc_width, doc_height)

        # convert pixel data to a PIL image
        size = (doc_width, doc_height)
        pil_img = Image.frombytes(IM_MODE, size, pixel_data)

        # from PIL to numpy image and save the image to the working directory
        numpy_img = Engine.pil2numpy(pil_img=pil_img)
        cv2.imwrite(INPUT_IMAGE_PATH, numpy_img)

        # save the selection mask
        selection = Krita.instance().activeDocument().selection()
        mask = np.zeros((doc_height, doc_width), dtype=np.uint8)
        mask_x, mask_y, mask_width, mask_height = 0, 0, doc_width, doc_height
        if selection == None:
            # no selection!
            # self.popup("{} {} {} {} {}".format(selection.x(), selection.y(), doc_width, doc_height, len(pixels)))
            # take the full image
            mask = mask + 255
        else:
            # get the pixel data from the selection
            mask_x, mask_y = selection.x(), selection.y()
            mask_width, mask_height = selection.width(), selection.height()
            pixels = selection.pixelData(mask_x, mask_y, mask_width, mask_height)
            # create and save the binary mask
            obj_mask = Engine.selection2mask(pixels, mask_width, mask_height)
            mask[mask_y:mask_y+mask_height, mask_x:mask_x+mask_width] = obj_mask
        cv2.imwrite(INPUT_MASK_PATH, mask)

        self.loading_bar.setVisible(True) # set the loading bar to show
        self.btn_run_engine.setEnabled(False)
        
        # export the config file
        Engine.export_config(
            input_path=INPUT_IMAGE_PATH,
            input_mask=INPUT_MASK_PATH,
            output_pix_path=OUTPUT_IMAGE_PATH,
            output_norm_path=OUTPUT_NORMAL_PATH,
            xtc_path=XTC_PATH,
            norm_palette_size=input_values["norm_palette"],
            mask_region=(mask_x, mask_y, mask_width, mask_height),
            factor=input_values["factor"],
            palette=input_values["palette"],
            dither=input_values["dither"])
        # fire up the pixelization and normalmap subprocesses
        normal_process = subprocess.Popen([
            ENGINE_PYTHON_PATH,
            NORMALGEN_ENTRY_POINT,
            WORKING_DIR+"/my_extension",
            CONFIG_PATH])
        pixelizer_process = subprocess.Popen([
            ENGINE_PYTHON_PATH,
            PIXELIZER_ENTRY_POINT,
            WORKING_DIR+"/my_extension",
            CONFIG_PATH])

        # poll on the subprocess and update the UI
        while (pixelizer_process.poll() is None) or (normal_process.poll() is None):
            QApplication.processEvents()

        # the pixelized output file should be saved at OUTPUT_IMAGE_PATH
        pix_im = Engine.load_img(OUTPUT_IMAGE_PATH)
        pix_norm_im = Engine.load_img(OUTPUT_NORMAL_PATH)

        # scale the pixelized image
        if rescale_output:
            # scale image back to the original scale
            pix_im = cv2.resize(pix_im, dsize=(
                pix_im.shape[1] * input_values["factor"], pix_im.shape[0] * input_values["factor"]), 
                interpolation=cv2.INTER_NEAREST)
        pix_dims = pix_im.shape
        pix_width, pix_height = pix_dims[1], pix_dims[0]

        # scale the normal image according to the pixelized image
        # they should match!
        if pix_norm_im.shape != pix_dims:
            pix_norm_im = cv2.resize(pix_norm_im, dsize=(pix_dims[1], pix_dims[0]), interpolation=cv2.INTER_NEAREST)

        # self.show_colour_palette(pix_im)

        # back to a PIL image
        pix_im = Engine.numpy2pil(pix_im)
        pix_norm_im = Engine.numpy2pil(pix_norm_im)

        # get byte format
        pix_im_bytes = pix_im.tobytes()
        pix_norm_im_bytes = pix_norm_im.tobytes()

        # create the documents with the generated images
        Engine.create_new_documents(pix_img=pix_im_bytes, norm_img=pix_norm_im_bytes, width=pix_width, height=pix_height)

        self.loading_bar.setVisible(False) # set the loading bar to not show
        self.btn_run_engine.setEnabled(True)


# And add the extension to Krita's list of extensions:
Krita.instance().addDockWidgetFactory(DockWidgetFactory(
    "My Extension", DockWidgetFactoryBase.DockRight, MyExtension))

